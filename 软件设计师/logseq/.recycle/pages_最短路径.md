- 单源点最短路径：
	- 所谓单源点最短路径，是指给定带权有向图G和源点v0，求从v0到G中其余各顶点的最短路径。==迪杰斯特拉(==Dijkstra)提出了按路径长度递增的次序产生最短路径的算法，其思想是：把网中所有的顶点分成两个集合S和T，S集合的初态只包含顶点v0，T集合的初态为网中除v0之外的所有顶点。凡以v0为源点，已经确定了最短路径的终点并入S集合中，顶点集合T则是尚未确定最短路径的顶点的集合。按各顶点与v0间最短路径长度递增的次序，逐个把T集合中的顶点加入到S集合中去，使得从v0到S集合中各顶点的路径长度始终不大于从v0到T集合中各顶点的路径长度。
	- 为了能方便地求出从v0到T集合中各顶点最短路径的递增次序，引入一个辅助向量dist。它的某一个分量dist[i]表示当前求出的从v0到终点vi的的最短路径长度。这个路径长度并不一定是真正的最短路径长度。它的初始状态为：若从v0到vi有弧，则dist[i]为弧上的权值；否则，置dist[i]为无穷大。显然，长度为dist[u]=min\{dist[i]|vi属于V(G)\}的路径就是从v0出发的长度最短的一条最短路径。此路径为(v0,u)，这时顶点u应从集合T中删除，将其并入集合S。
	- 设网用邻接矩阵arcs存储，那么每次选出一个顶点并入集合S后，就根据情况修改T集合中各顶点的路径长度dist。对于T集合中的某一个顶点i来说，其更短路径可能为(v0,…,vu,vi)。也就是说，若`dist[u] + arcs[u][i] < dist[i]`，则修改dist[i]，使`dist[i] = dist[u] + arcs[u][i]`。
	- 对T集合中各顶点的dist进行修改后，再从中挑选出一个路径长度最小的顶点，从T集合中删除并将其并入S集合。依此类推，就能求出源点到其余各顶点的最短路径长度。
	- 对于图8-42所示的有向网，用迪杰斯特拉算法求解顶点V0到达其余顶点的最短路径的过程如表8-1所示。
	  ![image-20211009115145575](https://img.mhugh.net/typora/image-20211009115145575.png)
	  ![image-20211009115256878](https://img.mhugh.net/typora/image-20211009115256878.png)
- 每对顶点间的最短路径：
	- 若每次以一个顶点为源点，重复执行迪杰斯特拉算法n次，便可求得网中每一对顶点之间的最短路径。下面介绍弗洛伊德(Floyd)提出的求最短路径的算法，该算法在形式上要简单一些。
	- 弗洛伊德算法思想是：假设图采用邻接矩阵的方式存储，需要求从顶点vi到vj的最短路径`arcs[i][j]`表示弧(vi,vj)的权值，若此弧不存在，则权值为区别于有效权值的一个数。如果存在vi到vj的弧，则从vi到vj存在一条长度为`arcs[i][j]`的路径，该路径不一定是最短路径，尚需进行n次试探。首先考虑路径(vi,v0,vj)是否存在（即判别路径(vi,v0)和(v0,vj)是否存在），若存在，则比较(vi,vj)与(vi,v0,vj)的路径长度，取较短者为从vi到vj的蹭顶点的序号不大于0的最短路径。假如在路径上再增加一个顶点v1，也就是说，如果(vi,…,v1)和(v1, …, vj)分别是当前找到的蹭顶点的序号不大于0的vi到v1以及v1到vj的最短路径，那么(vi, …, v1, …, vj)就有可能是从vi到vj的中间顶点的序号不大于1的最短路径。将它与已经得到的从vi到vj的中间顶点的序号不大于0的最短路径相比较，从中选出中间顶点的序号不大于1的最短路径之后，再增加一个顶点v2继续进行试探，依此类推。在一般情况下，若(vi, …, vk)和(vk, …, vj)分别是从vi到vk和vk到vj的中间顶点的序号不大于k-1的最短路径，则将(vi, …, vk, …, vj)与已经得到的从vi到vj的中间顶点的序号不大于k-1的最短路径相比较，长度较短者便是从vi到vj的中间顶点的序号不大于k的最短路径。这样，在经过n次试探后，最后求得的必是从vi到vj的最短路径。按此方法，可以同时求得各对顶点间的最短路径。