filters:: {"索引" false}
title:: 面向对象技术/面向对象基础/面向对象程序设计
alias:: 面向对象程序设计

- **程序设计范型**（Programming Paradigm）是人们在程序设计时所采用的基本方式模型，决定了程序设计时采用的思维方式、使用的工具，同时又有一定的应用范畴。其发展经历了**过程程序设计**、**模块化程序设计**、**函数程序设计**、**逻辑程序设计**，发展到现在的**面向对象程序设计**范型。
- 面向对象程序设计（Object-Oriented Programming，OOP）的实质是选用一种面向对象程序设计语言（Object-Oriented Programming Language，OOPL），采用对象、类及其相关概念所进行的程序设计。它的关键在于加入了类和继承性，从而进一步提高了抽象程度。特定的OOP概念一般是通过OOPL中特定的语言机制来体现的。本节以C++语言为主从程序设计的角度进一步讨论这些概念。
- OOP现在已经扩展到系统分析和软件设计的范畴，出现了面向对象分析和面向对象设计的概念，这两部分内容见本节的7.1.2和7.1.3两小节。
- ## 类
	- 通常，在介绍OOP的书籍或文章中总是先引入对象的概念，然后从对对象进行抽象的角度来引入类的概念。但是，当设计和实现一个面向对象的程序时，首先接触到的不是对象，而是类和类层次结构。
	- 类具有实例化功能，包括实例生成（由类的Constructor完成）和实例消除（由类的Destructor完成）。类的实例化功能决定了类及其实例具有下面的特征。
		- > 1. 同一个类的不同实例具有相同的数据结构，承受的是同一方法集合所定义的操作，因而具有规律相同的行为。
		  > 2. 同一个类的不同实例可以持有不同的值，因而可以具有不同的状态。
		  > 3. 实例的初始状态（初值）可以在实例化时确定。
- ## 继承和类层次结构
	- 孤立的类只能描述实体集合的特征同一性，而客观世界中实体集合的划分通常还要考虑实体特征方面有关联的相似性。在OOP中使用继承机制解决这一问题。
	- 在OOPL中，继承一般通过定义类之间的关系来体现。
	- 在一个面向对象系统中，子类与父类之间的继承关系构成了这个系统的类层次结构，可以用树（对应于单继承）或格（对应于多继承）这样的图来描述。
	- 当执行一个子类的实例生成方法时，首先在类层次结构中从该子类沿继承路径上溯至它的一个基类，然后自顶向下执行该子类所有父类的实例生成方法；最后执行该子类实例生成方法的函数体。当执行一个子类的实例消除方法时，顺序恰好与执行该子类实例生成方法相反：先执行该子类实例消除方法的函数体，再沿继承路径自底向上执行该子类所有父类的实例消除方法。
	- 与一般数据类型的实例化过程相比，类的实例化过程是一种实例的合成过程，而不仅仅是根据单个类型进行的空间分配、初始化和绑定。
	- OOPL中的继承机制体现了一条重要的面向对象程序设计原则：开发人员在构造程序时不必从零开始，而只需对差别进行程序设计。支持继承也是OOPL与传统程序设计语言在语言机制方面最根本的区别。
- ## 对象、消息传递和方法
	- 对象是类的实例。尽管对象的表示在形式上与一般数据类型十分相似，但是它们之间存在一种本质区别：对象之间通过消息传递方式进行通信。
	- 消息传递源是一种与通信有关的概念，OOP使得对象具有交互能力的主要模型就是消息传递模型。对象被看成用传递消息的方式互相联系的通信实体，它们既可以接收，也可以拒绝外界发来的消息。
	- 一般情况下，对象接收它能够识别的消息，拒绝它不能识别的消息。对于一个对象而言，任何外部的代码都不能以任何不可预知或事先不允许的方式与这个对象进行交互。
	- 发送一条消息至少应给出一个对象的名字和要发给这个对象的那条消息的名字。通常，消息的名字就是这个对象中外界可知的某个方法的名字。在消息中，经常还有一组参数（也就是那个方法所要求的参数），将外界的有关信息传给这个对象。
	- 对于一个类来说，它关于方法界面的定义规定了实例的消息传递协议，而它本身则决定了消息传递的合法范围。由于类是先于对象构造而成的，所以一个类为它实例提供了可以预知的交互方式。例如，假设m1是类Manager的一个实例（或对象），当外界要求把这个对象所代表的那位经理的级别改变为2时，就应以下面的方式向这个对象发出一条消息：
	  ```
	  m1.ChangeLevel(2);
	  ```
- ## 对象自身引用
	- 对象自身引用（self-Reference）是OOPL中的一种特有结构。这种结构在不同的OOPL中有不同的名称，在C++和Java中称为this，在Smalltalk-80、Object-C和其他一些OOPL中则称为self。
	- 以C++语言为例，对于类c和方法c::m，在c::m方法中出现的c的成员名n将被编译程序按this->n来对待。这里的this是一个类型为c*的指针（在Java语言中this是一个引用），它的值由语言中的消息传递机制提供。
	- 对象自身引用的值和类型分别扮演了两种意义的角色：对象自身引用的值使得方法体中引用的成员名与特定的对象相关，对象自身引用的类型则决定了方法体被实际共享的范围。
	- 对象自身引用机制使得在进行方法的设计和实现时并不需要考虑与对象联系的细节，而是从更高一级的抽象层次，也就是类的角度来设计同类型对象的行为特征，从而使得方法在一个类及其子类的范围内具有共性。在程序运行过程中，消息传递机制和对象自身引用将方法与特定的对象动态地联系在一起，使得不同的对象在执行同样的方法体时，可以因对象的状态不同而产生不同的行为，从而使得方法对具体的对象具有个性。
- ## 重置
	- 重置或覆盖（overriding）是在类中重新定义父类中已经定义的方法，其基本思想是通过一种动态绑定机制的支持，使得子类在继承父类接口定义的前提下用适合自己要求的实现去转换父类中的相应实现。
	- 在OOPL中，重置机制有相应的语法供开发人员选择使用。在C++语言中，通过==虚拟函数==（Virtual Function）的定义来进行重置的声明，通过==虚拟函数跳转表==（Virtual Function Jump Tables，VTBL）结构来实现重置方法体的动态绑定。在Java语言中，通过抽象方法（Abstract Method）进行重置的声明，通过方法查找（Method Loopup）实现重置方法体的动态绑定。
- ## 类属类
	- 类属是程序设计语言中普遍注重的一种参数多态机制，在OOPL中也不例外。本节主要介绍与类有关的类属。
	- 在C++中，类属有专门的术语——template。
	- 【例7.4】类属类。
	  ```c
	  template <class T>class Vector {
	  		T *v;
	  		int sz;
	  	public:
	  		T& operator[](int i); //运算符过载
	  		Vector(int VectorSize);
	  		/*...*/
	  }
	  ```
	  其中，`<class T>`中的class用来说明T是一个类型参数，但并不意味着T一定是一个类，也可以是基本类型。
	- 类属类可以看成是类的模板。一个类属类是关于一组类的一个特性抽象，它强调的是这些类的成员特征中与具体类型无关的那些部分，而与具体类型相关的那些部分则用变元来表示。这就使得对类的集合也可以按照特性的相似性再次进行划分。类属类的一个重要作用，就是对类库的建设提供了强有力的支持。
	- 重置和类属都是一种多态机制，多态的基本概念以及多态的分类见本章7.1节，对于其他种类的多太不在本节进行介绍。
- ## 无实例的类
	- 在前几节中曾指出，类是对象的模板，对象是类的实例。那么是否每个类都至少有一个实例？如果在类之间没有定义继承关系，回答是肯定的。这是因为若存在没有实例的类，那么这样的类对程序的行为没有任何贡献，因而是冗余的。相反如果存在继承关系，那么的确有可能在类层次结构的较高层次上看到始终没有实例的类。
	- 要创建无实例的类，仍然需要语言的支持。在C++和Java语言中，抽象类就是这样的类。在C++中通过在类中定义纯虚拟函数来创建一个抽象类，在Java中通过将一个类声明为抽象类来创建一个抽象类，并在抽象类中定义抽象方法，抽象类中也可以没有抽象方法。