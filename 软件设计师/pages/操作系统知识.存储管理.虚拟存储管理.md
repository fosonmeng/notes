title:: 操作系统知识/存储管理/虚拟存储管理

- 如果一个作业只部分装入主存便可开始启动运行，其余部分暂时留在磁盘上，需要时再装入主存。这样可以有效地利用主存空间，从用户角度看，该系统所具有的主存容量将比实际主存容量大得多，人们把这样的存储器称为虚拟存储器。虚拟存储器是为了扩大主存容量而采用的一种设计方法，其容量是由^^计算机的地址结构^^决定的。
- ## 程序局部性原理
	- 早在1968年P.Denning就指出过，程序在执行时将呈现出局部性规律，即在一段时间内程序的执行仅局限于某个部分。相应地，它所访问的存储空间也局限于某个区域内。程序的局限性表现在时间局限性和空间局限性两个方面。
	- ### 时间局限性
		- 如果程序中的某条指令一旦执行，则不久的将来该指令可能再次被执行；如果某个存储单元被访问，则不久以后该存储单元可能再次被访问。产生时间局限性的典型原因是在程序中存在着大量的<u>循环操作</u>。
	- ### 空间局限性
		- 一旦程序访问了某个存储单元，则在不久的将来，其附近的存储单元也最有可能被访问。即程序在一段时间内所访问的地址，可能集中在一定的范围内，其典型原因是程序是<u>顺序执行</u>的。
- ## 虚拟存储器的实现
	- 虚拟存储器是具有请求调入功能和置换功能，能仅把作业的一部分装入主存便可运行作业的存储器系统，是能从逻辑上对主存容量进行扩充的一种虚拟的存储器。其逻辑容量由==主存和外存容量之和==以及==CPU可寻址的范围==来决定，其运行速度接近于主存速度，成本也下降。
	- 虚拟存储实现主要有如下三种方式：
	  ![image.png](../assets/image_1648975393172_0.png)
	- ### 请求分页系统
		- 它是在分页系统的基础上，增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。它允许只装入若干页的用户程序和数据（而非全部程序）就可以启动运行，以后再通过调页功能和页面**置换**功能陆续把将要使用的页面调入主存，同时把暂不运行的页面置换到外存上，置换时以页面为单位。
	- ### 请求分段系统
		- 在分段系统的基础上，增加了请求调段和分段置换功能所形成的段式虚拟存储系统。它允许只装入若干段（而非全部段）的用户程序和数据就可以启动运行，以后再通过调段功能和置换功能将不运行的段调出，同时调入将要运行的段，置换是以段为单位。
	- ### 请求段页式系统
		- 在段页式系统的基础止，增加了**请求调页**和**页面置换**功能所形成的段页式虚拟存储系统。
- ## 请求分页管理的实现
	- 请求分页是在纯分页系统的基础上，增加了请求调页功能、页面置换功能所形成的页式虚拟存储系统，是目前常用的一种虚拟存储器的方式。
	- 请求分页的页表机制是在纯分页的页表机制上形成的，由于只将应用程序的一部分调入主存，还有一部分仍在磁盘上，故需在页表中再增加若干项，如状态位、访问字段和辅存地址等供程序（数据）在换进、换出时参考。
	- 请求分页系统中的地址变换机构，是在分页系统的地址变换机构的基础上增加了某些功能，如产生和处理缺页中断、从主存中换出一页实现虚拟存储。
	- 请求分页系统中，每当所要访问的页面不在主存时，便要产生一个缺页中断，请求OS将所缺的页调入主存，这是由**缺页中断** #缺页中断 机构完成的。
	- ### 缺页中断
		- 缺页中断与一般中断的主要区别如下：
			- 缺页中断在==指令执行期间==产生和处理中断信号，而一般中断在一条指令执行完，下一条指令开始执行前检查和处理中断信号。
			- 发生缺页中断时，返回到被中断指令的开始重新执行该指令，而一般中断返回到下一条指令执行。
			- 一条指令在执行期间，可能会产生多次缺页中断。
		- 缺页中断率 f：
		  $$A = S+F， f=F/A$$
		  **S**成功的访问次数，**F**不成功的访问次数（缺页中断次数），**A**总的访问次数
			- 分配给作业的主存块数。分配给作业的主存块数多，则缺页中断就低；反之，缺页中断率就高。
			- 页面的大小，如果划分的页面大，则缺页中断率就低，否则缺页中断率就高。但它们之间的关系不是简单的反比关系。
			- 页面调度算法。
			- 作业本身的程序编制方法。程序编制的方法不同，对缺页中断的次数有很大影响。
- ## 页面置换算法
	- ### 最佳（Optimal）置换算法
		- 这是一种理想化的算法，即选择哪些是永不使用的，或者是在最长时间内不再被访问的页面置换出去。这种方法性能最好，但实际上难于实现。要确定哪一个页面是未来最长时间内不再被访问的是很难的，所以该算法通常用来==评价其他算法==。
			- 选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。
			- 可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。
	- ### 先进先出（FIFO）置换算法
		- 先入先出，即淘汰最早调入的页面。
	- ### 最近最少未使用（Least Recently Used，LRU）置换算法
		- 用过去的历史预测将来，选最近最长时间没有使用的页淘汰(也称最近最少使用)。
		- LRU准确实现：计数器法，页码栈法。
		- 由于代价较高，通常不使用准确实现，而是采用近似实现，例如Clock算法。
	- ### 最近未用（Not Used Recently，NUR）置换算法
		- 将最近一段时间未引用过的页面换出。这是一种LRU的近似算法。该算法为每个页面设置一位访问位，将主存中的所有页面都通过链接指针链成一个循环队列。当某页被访问时，其访问位置1.在选择一页淘汰时，检查其访问位，如果是0，则选择该页换出；若为1，则重新置为0，暂不换出该页，在循环队列中检查下一个页面，直到访问位为0的页面为止。由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，所以把该算法称为最近未用算法。
	- **内存抖动现象**：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的。
	- **Belady现象**：对有的页面置换算法，页错误率可能会随着分配帧数增加而增加。FIFO会产生Belady异常。栈式算法无Belady异常，LRU，LFU（最不经常使用），OPT都属于栈式算法。
- ## 工作集
	- 所谓工作集，是指在某段时间间隔( \delta ) 里，进程实际要访问的页面的集合。工作集的理论是在1968年由Denning提出来的，他认为，虽然程序只需有少量的几页在主存就可以运行，但为了使程序能够有效地运行，较少地产生缺页，就必须使程序的工作集驻留在主存中。
	- 把某进程在时间t的工作集记为$$\omega(t, \Delta)$$，把变量 $$\Delta$$ 称为工作集“**窗口尺寸**（Window Size）”。正确选择工作集窗口（$$\Delta$$）的大小，对存储器的有效利用和系统吞吐量的提高，都将产生重要的影响。
	- 程序在运行时对页面的^^访问量不均匀^^的，即往往在某段时间内的访问仅局限于较少的若干个页面，如果能够预知程序在某段时间间隔内要访问哪些页面，并能将它们提前调入主存，将会大大地降低缺页率，从而减少置换工作，提高CPU的利用率。当每个工作集都已达到最小值时，卡萨布兰卡管理程序跟踪进程的缺页数量，根据主存中自由页面数量可以适当增加其工作集的大小。
	-