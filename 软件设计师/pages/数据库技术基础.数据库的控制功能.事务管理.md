alias:: 事务管理

- **事务**是一个操作序列，这些操作“要么都做，要么都不做”，是数据库环境中不可分割的逻辑工作单位。事务和程序是两个不同的概念，一般一个程序可包含多个事务。在SQL语言中，事务定义的语句有如下三条。
  > 1. BEGIN TRANSACTION：事务开始
  > 2. COMMIT：事务提交。该操作表示事务成功地结束，它将通知事务管理器该事务的所有更新操作现在可以被提交或永久的保留。
  > 3. ROLLBACK：事务回滚。该操作表示事务非成功地结束，它将通知事务管理器出故障了，数据库可能处于不一致状态，该事务的所有更新操作必须回滚或撤销。
	- _事务的概念来自于两个独立的需求：并发数据库访问，系统错误恢复。一个事务是可以被看作一个单元的一系列SQL语句的集合。_
- 事务具有原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。这4个特性也称事务的**ACID**性质。
  ![image.png](../assets/image_1649130252838_0.png)
	- **原子性** atomacity：要么都做，要么都不做。 _事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。_
	- **一致性** consistency。事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性状态。因此，当数据库只包含成功事务提交的结果时，称数据库处于一致性状态。
	- **隔离性** isolation。事务相互隔离。当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的。
	- **持久性** durability。一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效。
- ## 事务的隔离级别
	- 如果不对数据库进行并发控制 #并发控制 ，可能会产生异常情况：
	- 为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）
		- 未提交读(Read Uncommitted)：直译就是"读未提交"，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。Read Uncommitted允许脏读。
		- 已提交读(Read Committed)：直译就是"读提交"，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。 Read Commited 不允许脏读，但会出现非重复读。
		- 可重复读(Repeatable Read)：直译就是"可以重复读"，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。
		- 串行读(Serializable)：直译就是"序列化"，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。Serializable 不允许不一致现象的出现。
- ## 事务隔离的实现——锁
	- ((abe15846-c6c6-40ad-83de-afcd01456280))
	- **共享锁**(S锁)：用于只读操作(SELECT)，锁定共享的资源。共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。
	- **更新锁**(U锁)：用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。
	- **独占锁**(X锁，也叫排他锁)：一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。写是独占锁，可以有效的防止“脏读”。
	- > 1. Read Uncommited 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。
	  > 2 . Read Committed 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。
	  > 3. Repeatable Read 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。
	  > 4. Serializable 读加共享锁，写加排他锁，读写互斥。