title:: 数据结构/排序/简单排序

- ## 直接插入排序
	- **直接插入排序**是一种简单的排序方法，具体做法是：在插入第i个记录时，R1,R2,…,Ri-1已经排好序，这时将Ri的关键字ki依次与关键字ki-1,ki-2等进行比较，从而找到应该插入的位置并将Ri插入，插入位置及其后的记录依次向后移动。
	- 直接插入排序法在最好情况下（待排序列已按关键码有序——每趟排序只需作1次比较且不需要移动元素，因此n个元素排序时的总比较次数为n-1次，总移动次数为0次。在最坏情况下（元素已经逆序排列），进行第j趟排序时，待插入的记录需要同前面的每个记录进行比较，比较次数为j+1。因此，总比较次数为\( \displaystyle\sum_{i=2}^{n} i = \frac{(n+2)(n-1)}{2} \)，总移动次数为 \( \displaystyle\sum_{i=2}^{n}(i+1) = \frac{(n+3)(n-2)}{2} \)。
	- 直接插入排序是一种稳定的排序方法，其时间复杂度为O(n^{2})。排序过程中仅需要一个元素的辅助空间，空间复杂度为O(1)。
- ## 冒泡排序
	- n个记录进行冒泡排序的方法是：首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序，则交换这两个记录的值，然后比较第二个记录和第三个记录的关键字，依此类推，直至第n-1个记录和第n个记录的关键字比较过为止。上述过程称作第一趟冒泡排序，其结果是关键字最大的记录被旋转到第n个记录的位置上。然后进行第二趟冒泡排序，对前n-1个记录进行同样的操作，其结果是关键字次大的记录被旋转到第n-1个记录的位置上。最多进行n-1趟，所有记录有序排列。若在某趟冒泡排序过程没有进行相邻位置的元素交换处理，则可结束排序过程。
	- 冒泡排序法在最好情况下（待排序列已按关键码有序），只须作1趟排序，元素的比较次数为n-1且不需要交换元素，因此总比较次数为n-1次，总交换次数为0次。在最坏情况下（元素已经逆序排列），进行第j趟排序时，最大的j-1个元素已经排好序，其余的n-(j-1)个元素需要进行n-j次比较和n-j次交换，因此总比较次数为 \( \displaystyle\sum_{j=1}^{n-1} (n-j) =\frac{ n(n-1)}{2} \)，总交换次数为 \( \displaystyle\sum_{j=1}^{n-1} (n-j) = \frac{n(n-1)}{2} \)。
	- 冒泡排序是一种稳定的排序方法，其时间复杂度为O(n^{2})。排序过程中仅需要一个元素的辅助空间用于元素的交换，空间复杂度为O(1)。
- ## 简单选择排序
	- n个记录进行简单选择排序的基本方法是：通过n-i(1 <= i <= n)次关键字之间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i个记录进行交换，当i等于n时所有记录有序排列。
	- 【算法】简单排序算法
	  ```c
	  void SelectSort(int data[], int n)
	  /* 将数组data中的n个整数按非递减有序的方式进行排列 */
	  {
	    int i,j,k,temp;
	    for(i = 0; i<n-1;i+) {
	      k = i;
	      for(j = i+1;j<n;j++) /* 找出最小关键字的下标 */
	        if(data[j] < data[k]) k = j;
	      if (k!=i) {
	        temp = data[i]; data[i] = data[k]; data[k]=temp;
	      }
	    }
	  }
	  ```
	- 简单排序法在最好情况下（待排序列已按关键码有序），不需要移动元素，因此n个元素排序时的总移动次数为0次。在最坏的情况下（元素已经逆充排列），每趟排序移动记录的次数都为3次（两个数组元素交换值），共进行n-1趟排序，总移动次数为3(n-1)。无论在哪种情况下，元素的总比较次数为 
	  \( \displaystyle\sum_{i=1}^{n-1} (n-i) = \frac{n(n-1)}{2} \)。
	- 简单选择排序是一种==不稳定==的排序方法，其时间复杂度为O(n^{2})。排序过程中仅需要一个元素的辅助空间用于数组元素值的的交换，空间复杂度为O(1)。