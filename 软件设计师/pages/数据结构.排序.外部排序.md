title:: 数据结构/排序/外部排序
alias:: 外部排序

- 外部排序就是对大型文件的排序，待排序的记录存放在外存。在排序的过程中，内存只存储文件的一部分记录，整个排序过程需要进行多次内外存间的数据交换。
- 常用的外部排序方法是归并排序，一般分为两个阶段：在第一阶段，把文件中的记录分段读入内存，利用某种内部排序方法对记录段进行排序并输出到外存的另一个文件中，在新文件中形成许多有序的记录段；在第二阶段，对第一阶段形成的归并段用某种归并方法进行一趟趟地归并，使文件的有序段逐渐加长，直到将整个文件归并为一个有序段时为止。下面简单介绍常用的==多路平衡归并==方法。
- **k路平衡归并**是指文件经项目部排序的第一个阶段后，已经形成了由若干个初始归并段构成的文件。在这个基础上，反复将每次确定的k个归并段归并为一个有序段，将一个文件上的记录归并到另一个文件上。重复这个过程，直到文件中的所有记录都归并为一个有序段。
- 设已经得到8个初始归并段，如图8-58所示，其中bi表示第i个归并段。
  ![image.png](../assets/image_1648967708948_0.png){:height 144, :width 390}
- **树形选择排序**中，首先对n个记录的关键字进行两两比较，然后在 \( \lceil n/2 \rceil \) 个较小者之间再进行两两比较，如此重复，直到选出最小关键字的记录为止，该过程可用一棵有n个叶子节点的完全二叉树表示，如图8-59(a)所示。在树中，每个非终端节点中的关键字等于其左、右孩子节点中较小的关键字，则树根节点中的关键字即为所有叶子中的最小关键字。在输出最小关键字之后，更新最小关键字所在的叶子节点数据，然后从该叶子节点出发，与其左（兄弟）节点的关键字进行比较，修改从叶子节点到根的路径上各节点的关键字，则根节点的关键字即为次小关键字，如图8-59(b)所示。重复该过程，就可完成对所有记录的排序。
  ![image.png](../assets/image_1648967797256_0.png) 
  ![image.png](../assets/image_1648967827747_0.png)
- 在图8-59所示的图中，每个非终端节点记录了其左、右孩子中的“优胜者”，所以称其为“==胜者树==”。反之，若在双亲节点记录比较后的失败者，而让胜者去参加更上一层的比较，便可得到一棵“==败者树==”。这样一来，当优胜者到达父节点时，立刻就知道原先在此比较的失败者并与失败者进行比较，再次记录新的失败者并让优胜者去进行更上一层的比较。在败者树中，每个节点只需和其父节点进行比较，而在胜者树中，向上调整时节点需与兄弟节点比较，那么就需得到兄弟节点的位置信息，因此败者树更易于编程。
- 为了简便起风，设每个记录为一个整数，败者树用数组ls[]表示，ls[i]r值为败者所在归并段的段号，令ls[1]是树根节点，ls[0]是ls[1]（根）的父节点，ls[0]中存储每次选出的优胜者所在归并段的段号，输出时则取ls[0]指示的归并段的当前记录。例如，图8-60所示的是一棵实现8路归并的败者树，叶子节点的数据来自各个归并段；败者树的根节点ls[1]的父节点ls[0]中存储了优胜者（最小记录）所在的归并段。
  ![image.png](../assets/image_1648967967318_0.png)
- 图8-61所示的是输出一个记录后，重新调整后的败者树。
  ![image.png](../assets/image_1648967977740_0.png)
- 【算法】利用败者树实现k路平衡归并。
  ```c
  #define K 8
  #define MINKEY -1 /* 比所有关键字都小的一个值 */
  #define MAXKEY 10000 /* 比所有关键字都在的一个值 */
  void K_merge(int ls[K])
  /* ls[0]~ls[k-1]是败者树的内部节点。b[0]~b[k-1]分别存储K个初始归并段的当前记录 */
  /* 函数Get_next(i)从第i个归并段读取并返回当前记录，若归并段已空，则返回MAXKEY */
  { int b[K+1], i, q;
   for(i = 0; i< K;i++)
     b[i] = Get_next(i); /* 分别读取K个归并段的第一个关键字 */
    b[K] = MINKEY;
   for(i = 0; i < K;++i) ls[i] = K; /* 创建败者树，设置ls中败者的初值 */
   for(i = K;i>=0;--i) Adjust(ls, i); /* 依次从b[K-1],b[K-2],...,b[0]出发调整败者树 */
   while(b[ls[0]] != MAXKEY) { /* ls[0]记录本趟最小关键字所在的段号 */
     q = ls[0]; /* q是当前最小关键字所在的归并段 */
     printf("%d",b[q]);
     b[q] = Get_next(q);
     Adjust(ls, q); /* 调整败者树，选择新的最小关键字 */
   }
  }
  ```
- 【函数】败者树的调整：从叶子节点到根节点进行调整。
  ```c
  void Adjust(int ls[K], int s) /* 败者树存储在ls[1]~ls[K-1]中，s为记录所在归并段号 */
  { int t, temp;
   t = (s+K)/2; /* t为b[s]的父节点在败者树中的下标，K是归并段数 */
   while(t>0) { /* 若没有到达树根，则继续 */
     if(b[s] > b[ls[t]]) { /* 与父节点指示的数据进行比较 */
       temp = s; s = ls[t]; /* s指示胜者，胜者将去参加更上一层的比较 */
       ls[t] = temp; /* ls[t]记录败者所在的段号 */
     }
     t = t/2; /* 向树根加退一层 */
   }
   ls[0] = s; /* ls[0]记录本趟最小关键字所在的段号 */
  }
  ```