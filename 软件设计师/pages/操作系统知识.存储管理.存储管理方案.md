title:: 操作系统知识/存储管理/存储管理方案
alias:: 存储管理方案

- 存储管理的主要目的是解决多个用户使用主存的问题，其存储管理方案主要包括分区存储管理、分页存储管理、分段存储管理、段页式存储管理以及虚拟存储管理。
- ## 分区存储管理
	- 分区存储管理是早期的存储管理方案，其基本思想是把主存的用户区划分成若干个区域，每个区域分配给一个用户作业使用，并限定它们只能在自己的区域中运行。
	- ### 固定分区
		- 固定分区是一种静态分区方式，在系统生成时已将主存划分为若干个分区，每个分区的大小可不等。操作系统通过**主存分配情况表**管理主存。这种方法的突出问题是已分配区中存在**未用空间**，原因是程序或作业的大小不可能刚好等于分区的大小，故造成了空间的浪费。通常将已分配分区内的未用空间叫做**零头**或内碎片。
	- ### 可变分区
		- 可变分区是一种动态分区方式，存储空间的划分是在作业装入时进行的，故分区的 ==个数是可变的==，分区的大小刚好等于作业的大小。可变分区分配需要两种管理表格：已分配表，记录已分配分区的情况；未分配表，记录未分配分区的情况。
		- 可变分区的请求和释放分区的算法：
			- 最佳适应算法。假设系统中有n个<u>空白区</u>（自由区），每当用户申请一个空间时，将从这n个空白区中找到一个最接近用户需求的分区。这种算法能保留较大的空白区。但缺点是<u>空闲区</u>不可能刚好等于用户要求的区，所以必然要将一个分区一分为二，可是随着系统不断地释放空间，可能会使产生的小分区小到无法再继续分配，将这样的无用小分区称之为<u>外碎片</u>。
			- 最差适应算法。系统总是将用户作业装入<u>最大的空白分区</u>。这种算法将一个最大的分区一分为二，所以剩下的空白区通常也大，不容易产生外碎片。
			- 首次适应算法。每当用户作业申请一个空间时，系统总是从主存的<u>低地址开始</u>选择一个能装入作业的空白区。当用户释放空间时，该算法更易实现相邻的空白区合并。
			- 循环首次适应算法。与首次适应算法不同之处是，每次分配都是从<u>刚分配的空白区</u>开始寻找一个能满足用户要求的空白区。
		- 系统在不断的分配和回收中，必定会出现一些不连续的小的空闲区，尽管这些小的空闲区的总和超过某一个作业要求的空间，但是由于<u>不连续而无法分配</u>，产生了未分配区的无用空间，通常称之为<u>外碎片</u>。解决碎片的方法是拼接（或称紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一个方向连成一片。
	- ### 可重定位分区
		- 可重定位分区是解决碎片问题的简单而又行之有效的方法。基本思想是移动所有已分配好的分区，使之成为连续区域。如同队列有一个队员出列，指挥员叫大家“<u>靠拢</u>”一样。分区“靠拢”的时机是当用户请求空间得不到满足时进行。需要注意的是当进行分区“靠拢”时会导致地址发生变化，所以有地址重定位问题。
		- 分区保护的目的是防止未经核准的用户访问分区，常用如下两种方式：
			- 采用上界/下界寄存器保护。上界寄存器中存放的是作业的装入地址，下界寄存器装入的是作业的结束地址，形成 的物理地址必须满足如下条件：
			  `上界寄存器<=物理地址<=下界寄存器`
			- 采用基址/限长寄存器保护。基址寄存器中存放的是作业的装入地址，限长寄存器装入的是作业的长度，形成的我是地址必须满足如下条件：
			  `基址寄存器<=物理地址<基址寄存器+限长寄存器`
- ## 内存分配
- ### 进程内存分配的几种形式
- **分区式管理**：最简单直观的方式，在内存中分配一个区，将整个进程放入这个区。缺点是会产生外碎片，即时间长了会在分区之间产生难以被利用的小空间。
- **分页式管理**：将内存分成固定大小的页，分配若干页将整个进程载入。页面可以不连续是其重要优点，不会产生外碎片，更有效地利用了内存，不过会产生一些内碎片，即分配给进程的最后一个页往往不能正好用完，不过在页面大小不是很大的时候可以接受。
- **分段式管理**：将程序分为若干个段，如数据段和代码段，加以不同的保护。施加保护是分段式的优点，但其仍是向分区式管理一样的连续分配。
- **段页式管理**：同样将程序分段，加以不同的保护，但是各段不再连续分配，而采用分页式离散分配。
- ## 内存管理
- ### 程序可执行文件的结构
- 一个程序的可执行文件在内存中的结果，从大的角度可以分为两个部分：只读部分和可读写部分。只读部分包括程序代码（.text）和程序中的常量（.rodata）。可读写部分（也就是变量）大致可以分成下面几个部分：
  > 1. `.data`： 初始化了的全局变量和静态变量
  > 2. `.bss`： 即 Block Started by Symbol， 未初始化的全局变量和静态变量（这个我感觉上课真的没讲过啊我去。。。）
  > 3. `heap`： 堆，使用 malloc, realloc, 和 free 函数控制的变量，堆在所有的线程，共享库，和动态加载的模块中被共享使用
  > 4. `stack`： 栈，函数调用时使用栈来保存函数现场，自动变量（即生命周期限制在某个 scope 的变量）也存放在栈中。
- data 和 bss 区：
	- 这两个区经常放在一起说，因为他们都是用来存储全局变量和静态变量的，区别在于 data 区存放的是初始化过的， bss 区存放的是没有初始化过的，例如：
	  ```
	  int val = 3;
	  char string[] = "Hello World"; 
	  ```
	  这两个变量的**值**会一开始被存储在 .text 中（因为值是写在代码里面的），在程序启动时会拷贝到 .data 去区中。
	- 而不初始化的话，像下面这样：
	  ```
	  static int i; 
	  ```
	  这个变量就会被放在 bss 区中。
- **答疑一** 静态变量和全局变量。这两个概念都是很常见的概念，又经常在一起使用，很容易造成混淆。
	- **全局变量**：在一个代码文件（具体说应该一个 [translation unit/compilation unit](https://en.wikipedia.org/wiki/Translation_unit_%28programming))）当中，一个变量要么定义在函数中，要么定义在在函数外面。当定义在函数外面时，这个变量就有了全局作用域，成为了全局变量。全局变量不光意味着这个变量可以在整个文件中使用，也意味着这个变量可以在其他文件中使用（这种叫做 [external linkage](https://en.wikipedia.org/wiki/External_linkage)）。当有如下两个文件时；
	- _a.c_
	  ```
	  #include <stdio.h>
	  - int a;
	  - int compute(void);
	  - int main() {
	    a = 1;
	    printf("%d %d\n", a, compute());
	    return 0;
	  } 
	  ```
	- _b.c_
	  ```
	  int a;
	  - int compute(void) {
	    a = 0;
	    return a;
	  } 
	  ```
	- 在 Link 过程中会产生重复定义错误，因为有两个全局的 `a` 变量，Linker 不知道应该使用哪一个。为了避免这种情况，就需要引入 static。
	- **静态变量**： 指使用 static 关键字修饰的变量，static 关键字对变量的作用域进行了限制，具体的限制如下：
	  1. 在函数外定义：全局变量，但是只在当前文件中可见（叫做 internal linkage）
	  2. 在函数内定义：全局变量，但是只在此函数内可见（同时，在多次函数调用中，变量的值不会丢失）
	  3. （C++）在类中定义：全局变量，但是只在此类中可见
	- 对于全局变量来说，为了避免上面提到的重复定义错误，我们可以在一个文件中使用 static，另一个不使用。这样使用 static 的就会使用自己的 `a` 变量，而没有用 static 的会使用全局的 `a` 变量。当然，最好两个都使用 static，避免更多可能的命名冲突。
	- *注意*：'静态'这个中文翻译实在是有些莫名其妙，给人的感觉像是不可改变的，而实际上 static 跟不可改变没有关系，不可改变的变量使用 const 关键字修饰，注意不要混淆。
	- *Bonus 部分 —— extern*： extern 是 C 语言中另一个关键字，用来指示变量或函数的定义在别的文件中，使用 extern 可以在多个源文件中共享某个变量，例如[这里](https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files-in-c)的例子。 extern 跟 static 在含义上是“水火不容”的，一个表示不能在别的地方用，一个表示要去别的地方找。如果同时使用的话，有两种情况，一种是先使用 static，后使用 extern ，即：
	  ```
	  static int m;
	  extern int m; 
	  ```
	- 这种情况，后面的 m 实际上就是前面的 m 。如果反过来：
	  ```
	  extern int m;
	  static int m; 
	  ```
	  这种情况的行为是未定义的，编译器也会给出警告。
- **答疑二** 程序在内存和硬盘上不同的存在形式：
	- 这里我们提到的几个区，是指程序在内存中的存在形式。和程序在硬盘上存储的格式不是完全对应的。程序在硬盘上存储的格式更加复杂，而且是和操作系统有关的，具体可以参考[这里](https://en.wikipedia.org/wiki/Comparison_of_executable_file_formats)。一个比较明显的例子可以帮你区分这个差别：之前我们提到过未定义的全局变量存储在 `.bss` 区，这个区域不会占用可执行文件的空间（一般只存储这个区域的长度），但是却会占用内存空间。这些变量没有定义，因此可执行文件中不需要存储（也不知道）它们的值，在程序启动过程中，它们的值会被初始化成 0 ，存储在内存中。
- 栈：
	- 栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。
	- 栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的。能从栈获得的空间较小。如果申请的空间超过栈的剩余空间时，例如递归深度过深，将提示stackoverflow。
	- 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。
- 堆：
	- 堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用`malloc`和`free`时就是在操作堆中的内存。对于堆来说，释放工作由程序员控制，容易产生memory leak。
	- 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
	- 对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。
	- 堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
	- 计算机底层并没有对堆的支持，堆则是C/C++函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低。
- ## ------- 分隔线
- 虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 \+ 段内相对地址构成，这样的程序地址称为虚拟地址
- 逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址
- 物理地址：实际物理内存中所看到的存储地址称为物理地址
- 逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间
- 线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间
- 物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间
- MMU(Memery Management Unit内存管理单元)：实现将用户程序的虚拟地址（逻辑地址） → 物理地址映射的CPU中的硬件电路
- 基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算
- 偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值
- 虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址。
- 请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入