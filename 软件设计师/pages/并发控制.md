- 并发技术 #并发技术
- 所谓**并发**操作，是指在多用户共享的系统中，许多用户可能同时对同一数据进行操作。并发操作带来的问题是数据的不一致性，主要有三类：丢失更新、不可重复读和读脏数据。其主要原因是事务的并发操作破坏了事务的==隔离性==。DBMS的并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，避免用户得到不正确的数据。
- 并发操作带来的问题：
  ![image-20210819150956209](https://img.mhugh.net/typora/image-20210819150956209.png)
	- **脏读**(Dirty Read)：当一个事务读取另一个事务尚未提交的修改时，产生脏读。同一事务内不是脏读。 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。
	- **非重复读**(Nonrepeatable Read) 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。
	- **幻像读**(Phantom Reads) 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。
	- **丢失修改**(Lost Update)：
	  1. 第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。
	  2. 第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。
- 并发控制技术：
	- 封锁：
	  id:: abe15846-c6c6-40ad-83de-afcd01456280
		- **排它锁**。若事务T对数据对象A加上**X锁**，则只允许T读取和修改A，其他事务都不能再对A加任何类型的锁，直到T释放A上的锁。
		- **共享锁**。若事务T对数据对象A加上**S锁**，则只允许T读取A，但不能修改A，其他事务只能再对A加S锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A进行任何修改。
	- 三级封锁协议：
		- **一级封锁协议**。事务在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。一级封锁协议可以解决==丢失更新问题==。
		- **二级封锁协议**。在一级封锁协议的基础上，加上事务T在读数据R之前必须先对其加S锁，==读完后==即可释放S锁。二级封锁协议可以解决==读脏数据==的问题。但是，由于二级封锁协议读完了数据后即可释放S锁，所以不能保证~~可重复读~~。
		- **三级封锁协议**。在一级封锁协议的基础上，加上事务T在读数据R之前必须先对其加S锁，直到==事务结束时==释放S锁。三级封锁协议除了防止丢失修改和不读“脏”数据外，还进一步防止了==不可重复读==。
- 活锁与死锁：
	- 所谓**活锁**，是指当事务T1封锁了数据R，事务T2请求封锁数据R，于是T2等待，当T1释放了R上的封锁后，系统首先批准了T3请求，于是T2仍等待，当T3释放了R上的封锁后，又批准了T4请求，依此类推，使得T2可能永远等待的现象。
	- 所谓**死锁** #死锁 ，是指两个以上的事务分别请求封锁对方已经封锁的数据，导致长期等待而无法继续运行下去的现象。
- 并发调度的可串行性：
	- 多个事务的并发执行是正确的，当且仅当其结果与某一次序串行地执行它们时的结果相同，称这种调度策略是==可串行化的调度==。
	- 可串行性是并发事务正确性的准则，按这个准则规定，一个给定的并发调度，当且仅当它是可串行化的才认为是正确调度。
- 两段封锁协议：所谓两段封锁协议，是指所有事务必须分两个阶段对数据项加锁和解锁。即事务分两个阶段，第一阶段是==获得封锁==，事务可以获得任何数据项上的任何类型的锁，但不能释放；第二阶段是==释放封锁==，事务可以释放任何数据项上的任何类型的锁，但不能申请。
- 封锁的粒度：封锁对象的大小称为封锁的粒度。封锁的对象可以是==逻辑单元==（如属性、元组、关系、索引项、整个索引直到整个数据库），也可以是==物理单元==（如数据页或索引页）。