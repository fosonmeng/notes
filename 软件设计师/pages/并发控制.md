- 所谓并发操作，是指在多用户共享的系统中，许多用户可能同时对同一数据进行操作。并发操作带来的问题是数据的不一致性，主要有三类：丢失更新、不可重复读和读脏数据。其主要原因是事务的并发操作破坏了事务的==隔离性==。DBMS的并发控制子系统负责协调并发事务的执行，保证数据库的完整性不受破坏，避免用户得到不正确的数据。
- 并发操作带来的问题：
  ![image-20210819150956209](https://img.mhugh.net/typora/image-20210819150956209.png)
- 并发控制技术：
	- 封锁：
		- **排它锁**。若事务T对数据对象A加上**X锁**，则只允许T读取和修改A，其他事务都不能再对A加任何类型的锁，直到T释放A上的锁。
		- **共享锁**。若事务T对数据对象A加上**S锁**，则只允许T读取A，但不能修改A，其他事务只能再对A加S锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A进行任何修改。
	- 三级封锁协议：
		- **一级封锁协议**。事务在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。一级封锁协议可以解决==丢失更新问题==。
		- **二级封锁协议**。在一级封锁协议的基础上，加上事务T在读数据R之前必须先对其加S锁，==读完后==即可释放S锁。二级封锁协议可以解决==读脏数据==的问题。但是，由于二级封锁协议读完了数据后即可释放S锁，所以不能保证~~可重复读~~。
		- **三级封锁协议**。在一级封锁协议的基础上，加上事务T在读数据R之前必须先对其加S锁，直到==事务结束时==释放S锁。三级封锁协议除了防止丢失修改和不读“脏”数据外，还进一步防止了==不可重复读==。
- 活锁与死锁：
	- 所谓**活锁**，是指当事务T1封锁了数据R，事务T2请求封锁数据R，于是T2等待，当T1释放了R上的封锁后，系统首先批准了T3请求，于是T2仍等待，当T3释放了R上的封锁后，又批准了T4请求，依此类推，使得T2可能永远等待的现象。
	- 所谓**死锁**，是指两个以上的事务分别请求封锁对方已经封锁的数据，导致长期等待而无法继续运行下去的现象。
- 并发调度的可串行性：
	- 多个事务的并发执行是正确的，当且仅当其结果与某一次序串行地执行它们时的结果相同，称这种调度策略是==可串行化的调度==。
	- 可串行性是并发事务正确性的准则，按这个准则规定，一个给定的并发调度，当且仅当它是可串行化的才认为是正确调度。
- 两段封锁协议：所谓两段封锁协议，是指所有事务必须分两个阶段对数据项加锁和解锁。即事务分两个阶段，第一阶段是==获得封锁==，事务可以获得任何数据项上的任何类型的锁，但不能释放；第二阶段是==释放封锁==，事务可以释放任何数据项上的任何类型的锁，但不能申请。
- 封锁的粒度：封锁对象的大小称为封锁的粒度。封锁的对象可以是==逻辑单元==（如属性、元组、关系、索引项、整个索引直到整个数据库），也可以是==物理单元==（如数据页或索引页）。